## Codebase Patterns
- Project lives at eval/approach1/ - all source in eval/approach1/src/
- ESM project with "type": "module" in package.json
- TypeScript strict mode with JSX preserve and bundler module resolution
- Use `npx tsc --noEmit` from eval/approach1/ for typecheck
- Use `npx vitest run` from eval/approach1/ for tests
- Shared types in src/types.ts - import from there
- Logger utility in src/utils/logger.ts with chalk-based methods
- Tests go in __tests__/ directories alongside source (e.g., src/input/__tests__/diff-parser.test.ts)
- Import with .js extension for ESM (e.g., import from '../types.js')
- Don't use `promisify(execFile)` with vitest mocks - write a manual Promise wrapper instead
- When execFile has an options arg (e.g., cwd), mock must handle both 3-arg and 4-arg overloads
- ts-morph Project: use `useInMemoryFileSystem: true`, `skipFileDependencyResolution: true`, `skipAddingFilesFromTsConfig: true`
- Always use .tsx extension when creating ts-morph source files (for JSX parsing)
- JsxAttribute children: boolean attrs (e.g. `isDisabled`) have 1 child (name), value attrs have 3 (name, =, value) - check `getChildCount()` before accessing index 2
- Don't use regex with `g` flag and `.test()` in loops - the `lastIndex` state persists between calls. Use a fresh regex literal instead.
- Pattern detectors go in src/patterns/ with tests in src/patterns/__tests__/
- Registry is a module-level singleton array; use clearPatterns() in test beforeEach
- PatternDefinition already defined in src/types.ts; re-exported from src/patterns/types.ts
- Detector file pattern: export `{ pattern }`, call `registerPattern(pattern)` at module level, detect fn checks golden first (NOT_APPLICABLE), then null migration (FILE_MISSING), then compare (CORRECT/MISSING/INCORRECT)

# Ralph Progress Log
Started: Fri Feb 27 04:37:21 PM EST 2026
---

## 2026-02-27 - US-001
- What was implemented: Project scaffolding with package.json, tsconfig.json, types.ts, cli.ts, and logger.ts
- Files changed:
  - eval/approach1/package.json (dependencies: ts-morph, commander, chalk; devDeps: typescript, tsx, vitest, @types/node)
  - eval/approach1/tsconfig.json (strict, ESM, JSX preserve, bundler resolution)
  - eval/approach1/src/types.ts (all shared interfaces: FileDiff, ASTRepresentation, PatternDefinition, DetectionResult, DetectionStatus enum, EvalReport, MatchResult, NoiseInstance)
  - eval/approach1/src/cli.ts (commander-based CLI with --golden-pr, --migration-pr, --golden-dir, --migration-dir, --output-dir, --verbose)
  - eval/approach1/src/utils/logger.ts (chalk-based logging: info, warn, error, verbose, success)
- **Learnings for future iterations:**
  - npm install succeeds and npx tsc --noEmit passes clean
  - CLI uses commander with both PR URL and local directory modes
  - DetectionStatus enum has 6 values: CORRECT, MISSING, INCORRECT, UNNECESSARY, FILE_MISSING, NOT_APPLICABLE
---

## 2026-02-27 - US-002
- What was implemented: Unified diff parser that converts raw diff text into structured FileDiff objects
- Files changed:
  - eval/approach1/src/input/diff-parser.ts (parseDiff function: splits diff into file chunks, parses hunks, extracts added/removed lines with line numbers)
  - eval/approach1/src/input/__tests__/diff-parser.test.ts (10 tests: empty input, single-file, multi-file, renames, binary, no-newline-at-eof, hunk headers, multiple hunks, new file, deleted file)
- **Learnings for future iterations:**
  - Unified diff format: "diff --git a/path b/path" separates files, "@@ -old,count +new,count @@" separates hunks
  - The "\ No newline at end of file" marker should be preserved in hunk lines but not counted as added/removed
  - Renamed files use "rename from/to" lines and also have different --- and +++ paths
  - Binary files have "Binary files ... differ" or "GIT binary patch" markers
  - stripABPrefix utility removes a/ or b/ prefix from diff paths
---

## 2026-02-27 - US-003
- What was implemented: PR fetcher that calls `gh pr diff <url>` and returns parsed FileDiff[]
- Files changed:
  - eval/approach1/src/input/pr-fetcher.ts (fetchPRDiff, validateGhCli functions with manual execFile async wrapper)
  - eval/approach1/src/input/__tests__/pr-fetcher.test.ts (9 tests: gh auth validation, invalid URLs, mocked diff parsing, empty diff, error handling)
- **Learnings for future iterations:**
  - Don't use `promisify(execFile)` when mocking with vitest - the real execFile has util.promisify.custom that returns {stdout, stderr}, but vi.fn() doesn't. Write a manual Promise wrapper instead.
  - Mock `node:child_process` at module level with `vi.mock('node:child_process', ...)` and use sequential mock implementations for multi-call flows (auth check then actual command)
  - PR URL validation regex: `^https://github.com/[\w.-]+/[\w.-]+/pull/\d+/?$`
---

## 2026-02-27 - US-004
- What was implemented: Local directory reader that generates diffs from git repos and reads file contents for AST analysis
- Files changed:
  - eval/approach1/src/input/local-reader.ts (validateGitRepo, readLocalDiff, readFileContents functions with auto-detection of default branch and merge-base diffing)
  - eval/approach1/src/input/__tests__/local-reader.test.ts (13 tests: git repo validation, diff reading, default branch fallback, multi-file diffs, file content reading, error handling)
- **Learnings for future iterations:**
  - When mocking execFile with an options argument (cwd), the callback is the 4th argument, not the 3rd. Must handle both overload signatures in mock: `typeof _opts === 'function' ? _opts : callback`
  - Default branch detection: first try `git symbolic-ref refs/remotes/origin/HEAD`, then fall back to checking `main` and `master` with `git rev-parse --verify`
  - Use `git merge-base <default-branch> HEAD` to find the common ancestor, then `git diff <merge-base> HEAD` for the branch diff
  - readFileContents uses Promise.all for parallel file reads and silently skips unreadable files (deleted, binary, etc.)
---

## 2026-02-27 - US-005
- What was implemented: File matcher that pairs golden PR files with migration PR files by normalized path
- Files changed:
  - eval/approach1/src/analysis/file-matcher.ts (matchFiles function: normalizes paths, strips a/b/ prefixes, normalizes backslashes, excludes .snap and lockfiles, returns MatchResult with matched/missed/extra)
  - eval/approach1/src/analysis/__tests__/file-matcher.test.ts (11 tests: exact matches, missed files, extra files, both missed+extra, snapshot exclusion, lockfile exclusion, a/b prefix normalization, backslash normalization, empty inputs, golden-only, snapshot exclusion from both sides)
- **Learnings for future iterations:**
  - MatchResult type is defined in types.ts with matched pairs, missedFiles, and extraFiles arrays
  - Analysis modules go in src/analysis/ with tests in src/analysis/__tests__/
  - Excluded file patterns: .snap, package-lock.json, yarn.lock, pnpm-lock.yaml
  - Path normalization: strip a/ b/ prefixes + convert backslashes to forward slashes
---

## 2026-02-27 - US-006
- What was implemented: AST analyzer using ts-morph to extract import declarations and JSX component usages from TypeScript/TSX source code
- Files changed:
  - eval/approach1/src/analysis/ast-analyzer.ts (analyzeAST, analyzeFileDiff, reconstructContentFromDiff functions)
  - eval/approach1/src/analysis/__tests__/ast-analyzer.test.ts (17 tests: import extraction, JSX component/prop extraction, PF5/PF6 code snippets, error handling, diff reconstruction)
- **Learnings for future iterations:**
  - ts-morph Project config: `useInMemoryFileSystem: true`, `skipFileDependencyResolution: true`, `skipAddingFilesFromTsConfig: true` for isolated analysis
  - Always create source files with `.tsx` extension so JSX nodes are parsed correctly
  - JsxAttribute has 1 child (name only) for boolean shorthand props like `isDisabled`, but 3 children (name, =, value) for valued props - must check `getChildCount()` before accessing child at index 2
  - JsxSpreadAttribute has the spread expression at child index 2
  - `reconstructContentFromDiff()` rebuilds file content from added lines for PR mode where full files aren't available
  - analyzeAST exports: `analyzeAST(content, filePath)` for full file content, `analyzeFileDiff(diff)` for FileDiff objects
---

## 2026-02-27 - US-007
- What was implemented: CSS pattern analyzer using regex to detect PatternFly CSS class references, custom properties, and utility classes in source code
- Files changed:
  - eval/approach1/src/analysis/css-analyzer.ts (analyzeCSSPatterns main function + helpers: findPF5Classes, findPF6Classes, findPF5CustomProperties, findPF6CustomProperties, findPF5UtilityClasses, findPF6UtilityClasses)
  - eval/approach1/src/analysis/__tests__/css-analyzer.test.ts (20 tests: className props, template literals, string concatenation, custom properties, utility classes, version filtering, empty input)
- **Learnings for future iterations:**
  - CSS analyzer takes `Array<{ content: string; lineNumber: number }>` as input, making it easy to use with DiffLine arrays from FileDiff
  - Don't use global-flag regex with `.test()` in a loop - `lastIndex` state persists between calls causing alternate matches to fail. Use a fresh regex literal instead.
  - CSSClassReference has a `context` field that categorizes where the class appears: className-prop, template-literal, string-concat, or string-literal
  - PF class patterns: `pf-v5-*` / `pf-v6-*` for general classes, `pf-v5-u-*` / `pf-v6-u-*` for utility classes, `--pf-v5-*` / `--pf-v6-*` for CSS custom properties
---

## 2026-02-27 - US-008
- What was implemented: Pattern registry and detector framework with register, get, filter-by-complexity, and clear operations
- Files changed:
  - eval/approach1/src/patterns/types.ts (re-exports PatternDefinition and related types from src/types.ts)
  - eval/approach1/src/patterns/registry.ts (registerPattern, getPatterns, getPatternsByComplexity, clearPatterns functions)
  - eval/approach1/src/patterns/__tests__/registry.test.ts (9 tests: empty start, register+return, mutation safety, multiple patterns, filter by trivial/moderate/complex, empty filter result, clear)
- **Learnings for future iterations:**
  - Registry is a module-level singleton array - detectors will call registerPattern() at import time
  - getPatterns() returns a copy to prevent external mutation
  - clearPatterns() is needed for test isolation (call in beforeEach)
  - PatternDefinition is already fully defined in src/types.ts with the correct detect function signature
---

## 2026-02-27 - US-009
- What was implemented: 4 trivial pattern detectors for CSS and class renames, each self-registering with the pattern registry
- Files changed:
  - eval/approach1/src/patterns/css-class-prefix.ts (detects pf-v5-* -> pf-v6-* class prefix renames)
  - eval/approach1/src/patterns/utility-class-rename.ts (detects pf-v5-u-* -> pf-v6-u-* utility class renames)
  - eval/approach1/src/patterns/css-logical-properties.ts (detects physical -> logical CSS property renames like PaddingTop -> PaddingBlockStart)
  - eval/approach1/src/patterns/theme-dark-removal.ts (detects removal of theme="dark" prop)
  - eval/approach1/src/patterns/__tests__/trivial-detectors-batch1.test.ts (21 tests covering all 4 detectors)
- **Learnings for future iterations:**
  - Detector pattern: each detector file exports `{ pattern }` and calls `registerPattern(pattern)` at module level
  - Detector detect function takes (goldenDiff, migrationDiff | null, goldenAST?, migrationAST?) and returns DetectionResult
  - Always check golden diff first for relevance (return NOT_APPLICABLE if pattern not present)
  - Then check if migrationDiff is null (return FILE_MISSING)
  - Then compare migration behavior: CORRECT, MISSING, or INCORRECT
  - Tests use dynamic `import()` to get the pattern's detect function directly, avoiding registry state issues with module caching
  - Non-global regex (without `g` flag) is fine for `.test()` checks in detectors
---
